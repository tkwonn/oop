## Person-Wallet Relationship: Aggregation

#### Why?

**オブジェクトのライフサイクル**  

`Wallet`が`Person`が消滅されても他のスコープに存在し続けることができる = Aggregation  
`Wallet`が`Person`が消滅されると他のスコープに存在し続けることができない = Composition

`Person`クラスの設計を見ると、`Wallet`のインスタンスは`Person`クラスの中で生成され、`Person`が消去されると一緒に消去されるように見えます。
ただし、コードによると、`Person`はdropWalletとaddWalletメソッドを通じて`Wallet`を外部から受け取ったり、外部に渡すことが可能です。

つまり、dropWallet()後、`Wallet`は`Person`から独立して存在できる可能性があります。  
この設計により、例えば、`Wallet`の紛失や新しい`Wallet`の取得などの現実世界のシナリオをモデル化できます。

これは`Wallet`オブジェクトが`Person`オブジェクト外でも存在し、使用され得ることを示しています。このため、`Wallet`と`Person`の関係はAggregation（集約）と表現する方が適切です。

Compositionの場合、大体コンストラクタのところでその新しいオブジェクトが作成され、private変数にします。親が完全にそのオブジェクトの所有者です。逆に、Aggregationの場合は別の他の場所からオブジェクトを作成し、親オブジェクトにメソッドかコンストラクタで渡します。

しかし上記のようなパターンもあるため、「どこで呼ぶかによって変わる」だとか「渡し方によって全部決まる」のような考え方ではなく、「クラスAとクラスBがどのように依存し合っているのか」、「オブジェクトのライフサイクルはどうなっているのか」に焦点を当てるべきである。

> Note:「CompositionはクラスAのコンストラクタの中でクラスBをnewする方法で実現し、Aggregationはコンストラクタの引数に外部からオブジェクトを注入して実現するんだ！！」みたいに脳死で考えてはいけない

Compositionである場合、`Wallet`は`Person`インスタンス内のスコープでしか存在しないのでインスタンスが死んだらgarbage collectorも`Wallet`を削除します。